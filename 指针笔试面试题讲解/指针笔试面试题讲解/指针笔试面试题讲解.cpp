#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
//int main()
//{
//	//数组名是首元素地址，有两个例外
//	//1.&数组名   2.sizeof(数组名)
//	//一维数组
//	int a[] = { 1,2,3,4 };
//	printf("%d\n", sizeof(a));//16  计算的是数组总大小，单位是字节
//	printf("%d\n", sizeof(a+0));//8 指针大小在64位机器上是8个字节（地址就是指针，指针就是地址）    
//	printf("%d\n", sizeof(*a));//4  *a=1
//	printf("%d\n", sizeof(a+1));//8 指针大小在64位机器上是8个字节（地址就是指针，指针就是地址）
//	printf("%d\n", sizeof(a[1]));//4
//	printf("%d\n", sizeof(&a));//8  &a取出的是数组的地址，但数组的地址也是地址，那就是指针
//	printf("%d\n", sizeof(*&a));//16 是数组的所有元素的大小
//	printf("%d\n", sizeof(&a+1));//8 地址就是指针，指针就是地址，大小为8字节（64）
//	printf("%d\n", sizeof(&a[0]));//8 地址就是指针，指针就是地址，大小为8字节（64）
//	printf("%d\n", sizeof(&a[0]+1));//8 地址就是指针，指针就是地址，大小为8字节（64）
//	
//	//字符数组
//	char arr[] = { 'a','b','c','d','e','f' };
//	printf("%d\n", sizeof(arr));//6 求的是整个数组的大小
//	printf("%d\n", sizeof(arr+0));//8 首元素地址.地址大小是不分贵贱的
//	printf("%d\n", sizeof(*arr));//1  字符a的大小
//	printf("%d\n", sizeof(arr[1]));//1 字符b的大小
//	printf("%d\n", sizeof(&arr));//8   地址就是指针，指针就是地址
//	printf("%d\n", sizeof(&arr+1));//8 地址就是指针，指针就是地址
//	printf("%d\n", sizeof(&arr[0]+1));//8 地址就是指针，指针就是地址
//
//	printf("%d\n", strlen(arr));//arr是首元素地址，代表strlen从首元素地址开始数，计算字符串的大小，
////\0的位置是不确定的，所以是随机值
//	printf("%d\n", strlen(arr + 0));//随机值
//	printf("%d\n", strlen(*arr));//这个代码是错误的
////strlen的参数部分要的是地址，我传了个字符a（ascll码值位97），以97为地址向后去找\0，那就是非法访问
//	printf("%d\n", strlen(arr[1]));//这个代码是错误的
////strlen的参数部分要的是地址，我传了个字符b（ascll码值位98），以98为地址向后去找\0，那就是非法访问
//	printf("%d\n", strlen(&arr));//随机值
////虽然取出的是数组的地址，但数组的地址也是从首元素的地址开始的，和第一行相同，\0位置不知道来哪里
//	printf("%d\n", strlen(&arr + 1));// 随机值
////道理相同， \0不知道来哪
//	printf("%d\n", strlen(&arr[0] + 1));//随机值
////道理相同， \0不知道来哪
//
//	char arr[7] =  "abcdef";
//	printf("%d\n", sizeof(arr));//7   \0 '0'都是字符类型，占一个字节ascll码值分别为48和0
//	printf("%d\n", sizeof(arr+0));//8 计算的是地址的大小
//	printf("%d\n", sizeof(*arr));//1 计算首元素所占空间的大小
//	printf("%d\n", sizeof(arr[1]));//1 计算的是第二个元素所占空间的大小
//	printf("%d\n", sizeof(&arr));//8 地址就是指针，指针就是地址
//	printf("%d\n", sizeof(&arr+1));//8 地址就是指针，指针就是地址
//	//&arr+1跳过的是整个数组的地址
//	printf("%d\n", sizeof(&arr[0]+1));//8 地址就是指针，指针就是地址
//
//	printf("%d\n", strlen(arr));// 6
//	printf("%d\n", strlen(arr + 0));// 6
//	printf("%d\n", strlen(*arr));//传过去的是字符a，字符a的ascll码值为是97，所以是非法访问
////所以这个代码是错误的，strlen的参数是指针接收地址，你给了个字符a，将97作为地址向后寻找\0，非法访问
////报错是读取位置0x00000061错误，6*16^1+1*16^0=97
//	printf("%d\n", strlen(arr[1])); //传98，那还是非法访问
//	printf("%d\n", strlen(&arr));//取到的是 数组的地址-存放到数组指针char（*p）[7]-p的类型为char（*）[7]
////strlen参数类型为const char*  所以这两个类型是不兼容的	
//	printf("%d\n", strlen(&arr + 1));//首先strlen参数类型和传过去的类型是不兼容的
////其次，如果能运行起来，那也是随机值，因为跳过整个数组后\0的位置依然还是不确定的
//	printf("%d\n", strlen(&arr[0] + 1)); //5  跳到b的地址，从b的地址开始往后数计算字符长度
//
//	const char* p = "abcdef";//把a的地址放到p里边
//	printf("%d\n", sizeof(p));//8 p里边存放的是地址，地址就是指针，指针就是地址，要么4字节要么8字节
//	printf("%d\n", sizeof(p+1));//8 p+1得到的是字符b的地址，那就是8个字节
//	printf("%d\n", sizeof(*p));//1 字符a所占空间的大小为1个字节
//	printf("%d\n", sizeof(p[0]));//1   其实就是arr[]
//	printf("%d\n", sizeof(&p));//8 p指向的是a的地址，这里只不过把p的地址拿出来
//	printf("%d\n", sizeof(&p+1));//8 跳过p的地址，指向p后边，那他还是个地址，也就是8字节
//	printf("%d\n", sizeof(&p[0]+1));//其实就是拿出来b的地址，那就是8个字节
//
//	printf("%d\n", strlen(p));//6 从首元素地址开始，往后找知道\0，总共有6个字符
//	printf("%d\n", strlen(p + 1));//5 从b的地址向后数
//	printf("%d\n", strlen(*p));//非法访问，人家要的是地址，你传过去个字符
//	printf("%d\n", strlen(p[0]));// 非法访问
//	printf("%d\n", strlen(&p));// 拿出了变量p的地址，向后去找字符串长度了，他其实传过去二级指针
//	printf("%d\n", strlen(&p + 1));// 不兼容，传过去的是二级指针（指针的地址），人家要的是一级指针
//	printf("%d\n", strlen(&p[0] + 1));// 从字符b开始往后数，大小应该是5

//	//二维数组
//	int a[3][4] = { 0 };
//	printf("%d\n", sizeof(&(a[0] + 1)));//发生语法错误了，只能对左值和函数进行取地址
//	printf("%d\n", sizeof(a));//3*4*4=48 sizeof(数组名)计算的是整个数组所占空间的大小
//	printf("%d\n", sizeof(a[0][0]));//4
//	printf("%d\n", sizeof(a[0]));//16 那其实代表的就是sizeof（数组名）4*4=16
////可以把二维数组看成一行行的一维数组，每个一维数组其实也有自己的数组名a[0],a[1],a[2]
////a[0]相当于第一行作为一维数组的数组名，sizeof（a[0]）计算的就是第一行所占空间的大小
//	printf("%d\n", sizeof(a[0]+1));//8  
////a[0]是第一行的数组名，数组名此时是首元素地址，其实就是第一行第一个元素的地址，所以a[0]+1
////就是第一行第二个元素的地址，大小为8个字节
//	printf("%d\n", sizeof(*(a[0]+1)));//4 求第一行第二个元素的大小，也就是4个字节
//	printf("%d\n", sizeof(a+1));//8 求的还是第二行数组的地址
////数组名代表首元素地址，a其实就是第一行（首元素）的地址，a+1就是第二行数组的地址
////此时要把二维数组想像成多个以多个一维数组为元素的数组
//	printf("%d\n", sizeof(*(a+1)));//16 
////其实相当于sizeof（第二行的数组名a[1]），那求的就是第二行数组空间所占大小，16个字节
//	printf("%d\n", sizeof(&a[0]+1));//8 
////计算第二行的地址所占空间的大小，&a[0]-&数组名-那就不代表首元素地址了，是第一行的地址
//	printf("%d\n", sizeof(*(&a[0]+1)));//16 求第二行所占空间的大小
//	printf("%d\n", sizeof(*a));//16 a是第一行的地址，sizeof（*a）求的是第一行数组所占空间的大小
//	printf("%d\n", sizeof(a[3]));//16 a[3]并不会真正访问第4行的数组
//// a[3]是二维数组的第四行，虽然没有第四行，但是类型是能够确定的，大小就是确定的。
//	
//	//return 0;
//}

//指针笔试题1：
//int main()
//{
//	int a[5] = { 1,2,3,4,5 };
//	int* ptr = (int*)(&a + 1);
////数组地址+1后还是数组地址，应该存到数组指针里面，但强制类型转换后，就可以存到ptr里了
//	printf("%d  %d", *(a + 1), *(ptr - 1));//2 5 
//	return 0;
//}

//指针笔试题2：
 
//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p;
////假设p的值为0x0000000000100000，如下表达式的值分别是多少？
////已知，结构体Test类型的变量大小是20个字节
//int main()
//{
//	p = (struct Test*)0x0000000000100000;//将整数强制类型转换为结构体类型
//	printf("%p\n", p + 0x1);//跳过20个字节 0x00000000001000014
//	printf("%p\n", (unsigned long)p + 0x1);//强制指针类型转换成整型类型，整型+1后，再打印16进制+1
//	printf("%p\n", (unsigned int*)p + 0x1);
////其实就是把指针变量转换成无符号整型指针，无符号整型指针+1跳过4个字节
////%p是打印变量的16进制
//	return 0;
//}
////考点：指针+-整数跳过几个字节，取决于指针类型
////内存是以字节为单位的，跳过几个字节，内存相应加减多少
//

//指针笔试题3：
//int main()
//{
//	int a[4] = { 1,2,3,4 };
//	int* ptr1 = (int*)(&a + 1);
//	int* ptr2 = (int*)((int)a + 1);
//	printf("%x %x", ptr1[-1], *ptr2);//ptr1[-1]==*（ptr1-1）
//	 //假设a的地址为0x00 00 00 05强制类型转换为整型后是5，5+1=6
//	 //再强制类型转换为int*指针变为0x00 00 00 06其实就是向后访问一个字节，因为内存是以字节为单位的
//
////a数组在内存中的布局为 01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 小端存储模式
////ptr2进行解引用操作时访问00 00 00 02拿出来进行打印时变为02 00 00 00那就是0x2 00 00 00
//	return 0; 
//}
//%p - 打印地址
//%x - 是16进制的格式打印

//指针笔试题4：
//int main()
//{
//	int a[3][2] = { (0,1),(2,3),(4,5)};//没有初始化的内容默认为0
//	int* p;
//	p = a[0];
//	printf("%d", p[0]);
//	return 0;
//}

//指针笔试题5：
//int main()
//{
//	int a[5][5];
//	int(*p)[4];//p指向数组的大小是4个整型，p+1就跳过4个整型，而a+1就跳过5个整型
//	p = a;//a是第一行数组的地址,类型为int(*)[5],而p的类型为int (*)[4]
////所以p访问数组时，以4个字节为单位，一下一下的访问
////p[4][2]是*（*（p+4）+2） 
////最后输出的就是指针-指针结果
//	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
//
////             a[0]       a[1]       a[2]       a[3]       a[4]
////内存情况 [][][][][] [][][][][] [][][][][] [][][][][] [][][][][]
////	       ^      ^        ^        ^        ^       ^        ^
////         p     p+1      p+2      p+3       p+4     p+5      p+6   
////%p打印的是-4的地址，因为地址其实就是-4在内存中的存储情况，那也就是打印-4的补码
//	return 0;
//}

//指针笔试题6：
//int main()
//{
//	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* ptr1 = (int*)(&aa + 1);
////数组指针才能存放数组的地址，所以要进行强制类型转换，将数组指针类型转换为整型类型
//	int* ptr2 = (int*)(*(aa + 1));
////*aa+1相当于aa[1],第二行首元素的地址 
//	printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));
//	return 0;
//}

//int* p = arr;
//*(p + 2) ==> *(arr + 2) ==> arr[2] ==> p[2];

//指针笔试题7：
//int main()
//{
//	const char* a[] = { "work","at","alibaba" };
////数组a里面的三个字符指针分别指向w，a，a的地址
//	const char** pa = a;
////数组a代表首元素地址，那也就是指向w的字符指针的地址，char*的地址就是char**类型
////*pa代表pa是一个指针，剩下的const char*代表pa所指向元素的类型，pa+1就跳过一个char*，
////那么pa就指向所指元素为a的指针
////例如：int*pa;*pa代表pa是一个指针，而剩下的int代表pa所指向的元素类型是int，pa+1就跳过一个int大小
//	pa++;
//	printf("%s\n", *pa);
////*pa就是指向元素为第二个a的指针，那也就是第二个a的地址（因为指针就是地址，地址就是指针）
////printf打印时，则以第二个a为起始点，打印字符串
//	return 0;
//}
//
//int main()
//{
//	const char*p= "abcdef";
////这种写法是将常量字符串的首字符a的地址放到指针变量p里面去
////那如果我想把多个常量字符串的首字符地址放到指针变量里面，那我就需要一个字符指针数组
//	return 0;
//}

//指针笔试题8：
//int main()
//{
//	const char* c[] = { "ENTER","NEW","POINT","FIRST" };
//	const char** cp[] = { c + 3,c + 2,c + 1,c };
//	const char*** cpp = cp;
//
//	printf("%s\n", **++cpp);//最终拿到P的地址，那么打印结果为POTER
//	printf("%s\n", *-- * ++cpp + 3);//++ -- *（解引用操作符）优先级要比+高
////*++cpp拿到c+1，然后--变为c，*c拿到E的地址，然后再往后+3个字节
//	printf("%s\n", *cpp[-2] + 3);
////cpp[-2]==*(cpp-2),那就是拿到了c+3，然后再对c+3进行解引用操作，得到指向F的指针char*，然后再+3
////，跳过3个字节，因为char*所指向元素是const char，1*3=3个字节
//	printf("%s\n", cpp[-1][-1] + 1);
////结果可以转化为*(*(cpp-1)-1)+1
//	return 0;
//}
//答案为POTER, ER,ST,EW
//打印%s可以传过去地址，它会从这个地址开始往后找并且进行打印，直到\0结束
//自增运算符和自减运算符都会改变变量本身的值




















































































